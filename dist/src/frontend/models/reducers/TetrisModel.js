"use strict";
/***********************************************************************************
 *                                                                                  *
 *   Redux Reducers and React Context API Provider/Consumer for state TetrisModel   *
 *   Generated by ts2redux from Source file ../TetrisModel.ts                       *
 *                                                                                  *
 ***********************************************************************************/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var Colors;
(function (Colors) {
    Colors["EMPTY"] = "";
})(Colors = exports.Colors || (exports.Colors = {}));
var pieceDeclaration = function (color, rows) {
    var cells = new Array(rows.length);
    for (var i = 0; i < rows.length; i++) {
        var row = rows[i];
        cells[i] = new Array(row.length);
        for (var c = 0; c < row.length; c++) {
            if (row.charAt(c) == " ") {
                cells[i][c] = { color: Colors.EMPTY };
            }
            else {
                cells[i][c] = { color: color };
            }
        }
    }
    return {
        x: 0,
        y: rows.length * -1,
        width: rows.length,
        height: rows.length,
        cells: cells
    };
};
/**
 * [' O '],
 *  ['OOO'],
 *  [' O ']
 */
exports.createNewPiece = function (usingColor) {
    var items = [
        pieceDeclaration(usingColor, ["xx", "xx"]),
        pieceDeclaration(usingColor, ["   ", "xxx", " x "]),
        pieceDeclaration(usingColor, [" x ", " x ", "xx "]),
        pieceDeclaration(usingColor, [" x ", " x ", " xx"]),
        pieceDeclaration(usingColor, [" x  ", " x  ", " x  ", " x  "])
    ];
    return items[Math.floor(Math.random() * items.length)];
};
/**
 * @redux true
 */
var TetrisModel = /** @class */ (function () {
    function TetrisModel() {
        this.useColors = ["red", "blue", "green", "yellow", "brown", "orange"];
        this.lastUsedColor = Math.floor(Math.random() * this.useColors.length);
        this.points = 0;
        this.rows = 20;
        this.cols = 15;
        this.cells = [];
        this.gameOn = false;
        this.gameEnded = false;
        this.ticksPerMove = 10;
        this.tickCnt = 0;
        this.dx = 0;
        this.dy = 1;
    }
    TetrisModel.prototype.doesCollide = function (pieceX, pieceY, pieceCells) {
        var _this = this;
        var collides = false;
        var compareAgainst = pieceCells || this.activePiece.cells;
        compareAgainst.forEach(function (row, y) {
            row.forEach(function (cell, x) {
                if (cell.color === Colors.EMPTY)
                    return;
                if (pieceY + y >= _this.rows) {
                    collides = true;
                    return;
                }
                if (pieceX + x < 0 || pieceX + x >= _this.cols) {
                    collides = true;
                    return;
                }
                if (cell.color !== Colors.EMPTY) {
                    if (pieceY + y < 0)
                        return;
                    if (_this.cells[pieceY + y][pieceX + x].color !== Colors.EMPTY) {
                        collides = true;
                    }
                }
            });
        });
        return collides;
    };
    TetrisModel.prototype.tick = function () {
        this.tickCnt++;
        if (this.tickCnt >= this.ticksPerMove) {
            this.tickCnt = 0;
            this.step();
        }
    };
    TetrisModel.prototype.left = function () {
        if (!this.doesCollide(this.activePiece.x - 1, this.activePiece.y)) {
            this.activePiece.x--;
        }
    };
    TetrisModel.prototype.right = function () {
        if (!this.doesCollide(this.activePiece.x + 1, this.activePiece.y)) {
            this.activePiece.x++;
        }
    };
    // keyboard control for rotation, tries to rotate activePiece and if
    // it does not collide, rotation can be done
    TetrisModel.prototype.rotate = function () {
        var newOrientation = this.rotateCells(this.activePiece.cells);
        if (!this.doesCollide(this.activePiece.x, this.activePiece.y, newOrientation)) {
            this.activePiece.cells = newOrientation;
        }
    };
    // creates a new piece with rotated values
    TetrisModel.prototype.rotateCells = function (cells) {
        var res = new Array(cells.length);
        for (var j = 0; j < cells.length; j++) {
            res[j] = new Array(cells[j].length);
        }
        for (var j = 0; j < cells.length; j++) {
            var row = cells[j];
            for (var i = 0; i < row.length; i++) {
                res[i][j] = { color: Colors.EMPTY };
            }
        }
        for (var j = 0; j < cells.length; j++) {
            var row = cells[j];
            for (var i = 0; i < row.length; i++) {
                res[i][cells.length - j - 1] = row[i];
            }
        }
        return res;
    };
    TetrisModel.prototype.step = function () {
        if (this.gameOn) {
            if (!this.doesCollide(this.activePiece.x, this.activePiece.y + 1)) {
                this.activePiece.y++;
            }
            else {
                if (this.activePiece.y < 0) {
                    this.gameEnded = true;
                    this.gameOn = false;
                }
                else {
                    this.masonPiece();
                    this.dropRows();
                    this.activePiece = exports.createNewPiece(this.pickNextColor());
                    this.activePiece.x = Math.floor(Math.random() * 5);
                }
            }
        }
    };
    TetrisModel.prototype.pickNextColor = function () {
        this.lastUsedColor++;
        if (this.lastUsedColor >= this.useColors.length) {
            this.lastUsedColor = 0;
        }
        return this.useColors[this.lastUsedColor];
    };
    // adds the piece permanently to the structure
    TetrisModel.prototype.masonPiece = function () {
        var _this = this;
        var piece = this.activePiece;
        piece.cells.forEach(function (row, y) {
            if (piece.y + y < 0)
                return;
            row.forEach(function (cell, x) {
                if (cell.color !== Colors.EMPTY) {
                    _this.cells[piece.y + y][piece.x + x].color = cell.color;
                }
            });
        });
    };
    // drops full rows and adds points to the user
    TetrisModel.prototype.dropRows = function () {
        var nextRows = [];
        var emptyCnt = 0;
        for (var i = 0; i < this.cells.length; i++) {
            var row = this.cells[i];
            if (row.filter(function (cell) { return cell.color === Colors.EMPTY; }).length > 0) {
                nextRows.push(row);
            }
            else {
                emptyCnt++;
            }
        }
        if (emptyCnt > 0) {
            this.points += emptyCnt * emptyCnt * 10;
            while (emptyCnt-- > 0) {
                var newEmpty = new Array(this.cols);
                for (var col = 0; col < this.cols; col++) {
                    newEmpty[col] = { color: Colors.EMPTY };
                }
                nextRows.unshift(newEmpty);
            }
            this.cells = nextRows;
            this.ticksPerMove--;
        }
    };
    TetrisModel.prototype.clearCells = function () {
        this.cells = new Array(this.rows);
        for (var row = 0; row < this.rows; row++) {
            this.cells[row] = new Array(this.cols);
            for (var col = 0; col < this.cols; col++) {
                this.cells[row][col] = { color: Colors.EMPTY };
            }
        }
    };
    TetrisModel.prototype.resetGame = function () {
        this.clearCells();
        this.activePiece = exports.createNewPiece(this.pickNextColor());
        this.ticksPerMove = 10;
        this.tickCnt = 0;
    };
    TetrisModel.prototype.start = function () {
        this.resetGame();
        this.gameOn = true;
        this.gameEnded = false;
        this.points = 0;
    };
    return TetrisModel;
}());
exports.TetrisModel = TetrisModel;
var immer = require("immer");
var react_redux_1 = require("react-redux");
var React = require("react");
exports.mapStateToProps = function (state) {
    return {
        useColors: state.TetrisModel.useColors,
        lastUsedColor: state.TetrisModel.lastUsedColor,
        points: state.TetrisModel.points,
        rows: state.TetrisModel.rows,
        cols: state.TetrisModel.cols,
        cells: state.TetrisModel.cells,
        activePiece: state.TetrisModel.activePiece,
        gameOn: state.TetrisModel.gameOn,
        gameEnded: state.TetrisModel.gameEnded,
        ticksPerMove: state.TetrisModel.ticksPerMove,
        tickCnt: state.TetrisModel.tickCnt,
        dx: state.TetrisModel.dx,
        dy: state.TetrisModel.dy
    };
};
exports.mapDispatchToProps = function (dispatch) {
    return {
        tick: function () {
            return dispatch(RTetrisModel.tick());
        },
        left: function () {
            return dispatch(RTetrisModel.left());
        },
        right: function () {
            return dispatch(RTetrisModel.right());
        },
        rotate: function () {
            return dispatch(RTetrisModel.rotate());
        },
        step: function () {
            return dispatch(RTetrisModel.step());
        },
        masonPiece: function () {
            return dispatch(RTetrisModel.masonPiece());
        },
        dropRows: function () {
            return dispatch(RTetrisModel.dropRows());
        },
        clearCells: function () {
            return dispatch(RTetrisModel.clearCells());
        },
        resetGame: function () {
            return dispatch(RTetrisModel.resetGame());
        },
        start: function () {
            return dispatch(RTetrisModel.start());
        }
    };
};
exports.StateConnector = react_redux_1.connect(exports.mapStateToProps, exports.mapDispatchToProps);
var initTetrisModel = function () {
    var o = new TetrisModel();
    return {
        useColors: o.useColors,
        lastUsedColor: o.lastUsedColor,
        points: o.points,
        rows: o.rows,
        cols: o.cols,
        cells: o.cells,
        activePiece: o.activePiece,
        gameOn: o.gameOn,
        gameEnded: o.gameEnded,
        ticksPerMove: o.ticksPerMove,
        tickCnt: o.tickCnt,
        dx: o.dx,
        dy: o.dy
    };
};
var initWithMethodsTetrisModel = function () {
    var o = new TetrisModel();
    return {
        useColors: o.useColors,
        lastUsedColor: o.lastUsedColor,
        points: o.points,
        rows: o.rows,
        cols: o.cols,
        cells: o.cells,
        activePiece: o.activePiece,
        gameOn: o.gameOn,
        gameEnded: o.gameEnded,
        ticksPerMove: o.ticksPerMove,
        tickCnt: o.tickCnt,
        dx: o.dx,
        dy: o.dy,
        tick: o.tick,
        left: o.left,
        right: o.right,
        rotate: o.rotate,
        step: o.step,
        masonPiece: o.masonPiece,
        dropRows: o.dropRows,
        clearCells: o.clearCells,
        resetGame: o.resetGame,
        start: o.start
    };
};
/**
 * @generated true
 */
var RTetrisModel = /** @class */ (function () {
    function RTetrisModel(state, dispatch, getState) {
        this._state = state;
        this._dispatch = dispatch;
        this._getState = getState;
    }
    Object.defineProperty(RTetrisModel.prototype, "useColors", {
        get: function () {
            if (this._getState) {
                return this._getState().TetrisModel.useColors;
            }
            else {
                if (this._state) {
                    return this._state.useColors;
                }
            }
            throw "Invalid State in TetrisModel_useColors";
        },
        set: function (value) {
            if (this._state && typeof value !== "undefined") {
                this._state.useColors = value;
            }
            else {
                // dispatch change for item useColors
                if (this._dispatch) {
                    this._dispatch({
                        type: exports.TetrisModelEnums.TetrisModel_useColors,
                        payload: value
                    });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTetrisModel.prototype, "lastUsedColor", {
        get: function () {
            if (this._getState) {
                return this._getState().TetrisModel.lastUsedColor;
            }
            else {
                if (this._state) {
                    return this._state.lastUsedColor;
                }
            }
            throw "Invalid State in TetrisModel_lastUsedColor";
        },
        set: function (value) {
            if (this._state && typeof value !== "undefined") {
                this._state.lastUsedColor = value;
            }
            else {
                // dispatch change for item lastUsedColor
                if (this._dispatch) {
                    this._dispatch({
                        type: exports.TetrisModelEnums.TetrisModel_lastUsedColor,
                        payload: value
                    });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTetrisModel.prototype, "points", {
        get: function () {
            if (this._getState) {
                return this._getState().TetrisModel.points;
            }
            else {
                if (this._state) {
                    return this._state.points;
                }
            }
            throw "Invalid State in TetrisModel_points";
        },
        set: function (value) {
            if (this._state && typeof value !== "undefined") {
                this._state.points = value;
            }
            else {
                // dispatch change for item points
                if (this._dispatch) {
                    this._dispatch({
                        type: exports.TetrisModelEnums.TetrisModel_points,
                        payload: value
                    });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTetrisModel.prototype, "rows", {
        get: function () {
            if (this._getState) {
                return this._getState().TetrisModel.rows;
            }
            else {
                if (this._state) {
                    return this._state.rows;
                }
            }
            throw "Invalid State in TetrisModel_rows";
        },
        set: function (value) {
            if (this._state && typeof value !== "undefined") {
                this._state.rows = value;
            }
            else {
                // dispatch change for item rows
                if (this._dispatch) {
                    this._dispatch({
                        type: exports.TetrisModelEnums.TetrisModel_rows,
                        payload: value
                    });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTetrisModel.prototype, "cols", {
        get: function () {
            if (this._getState) {
                return this._getState().TetrisModel.cols;
            }
            else {
                if (this._state) {
                    return this._state.cols;
                }
            }
            throw "Invalid State in TetrisModel_cols";
        },
        set: function (value) {
            if (this._state && typeof value !== "undefined") {
                this._state.cols = value;
            }
            else {
                // dispatch change for item cols
                if (this._dispatch) {
                    this._dispatch({
                        type: exports.TetrisModelEnums.TetrisModel_cols,
                        payload: value
                    });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTetrisModel.prototype, "cells", {
        get: function () {
            if (this._getState) {
                return this._getState().TetrisModel.cells;
            }
            else {
                if (this._state) {
                    return this._state.cells;
                }
            }
            throw "Invalid State in TetrisModel_cells";
        },
        set: function (value) {
            if (this._state && typeof value !== "undefined") {
                this._state.cells = value;
            }
            else {
                // dispatch change for item cells
                if (this._dispatch) {
                    this._dispatch({
                        type: exports.TetrisModelEnums.TetrisModel_cells,
                        payload: value
                    });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTetrisModel.prototype, "activePiece", {
        get: function () {
            if (this._getState) {
                return this._getState().TetrisModel.activePiece;
            }
            else {
                if (this._state) {
                    return this._state.activePiece;
                }
            }
            return undefined;
        },
        set: function (value) {
            if (this._state && typeof value !== "undefined") {
                this._state.activePiece = value;
            }
            else {
                // dispatch change for item activePiece
                if (this._dispatch) {
                    this._dispatch({
                        type: exports.TetrisModelEnums.TetrisModel_activePiece,
                        payload: value
                    });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTetrisModel.prototype, "gameOn", {
        get: function () {
            if (this._getState) {
                return this._getState().TetrisModel.gameOn;
            }
            else {
                if (this._state) {
                    return this._state.gameOn;
                }
            }
            throw "Invalid State in TetrisModel_gameOn";
        },
        set: function (value) {
            if (this._state && typeof value !== "undefined") {
                this._state.gameOn = value;
            }
            else {
                // dispatch change for item gameOn
                if (this._dispatch) {
                    this._dispatch({
                        type: exports.TetrisModelEnums.TetrisModel_gameOn,
                        payload: value
                    });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTetrisModel.prototype, "gameEnded", {
        get: function () {
            if (this._getState) {
                return this._getState().TetrisModel.gameEnded;
            }
            else {
                if (this._state) {
                    return this._state.gameEnded;
                }
            }
            throw "Invalid State in TetrisModel_gameEnded";
        },
        set: function (value) {
            if (this._state && typeof value !== "undefined") {
                this._state.gameEnded = value;
            }
            else {
                // dispatch change for item gameEnded
                if (this._dispatch) {
                    this._dispatch({
                        type: exports.TetrisModelEnums.TetrisModel_gameEnded,
                        payload: value
                    });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTetrisModel.prototype, "ticksPerMove", {
        get: function () {
            if (this._getState) {
                return this._getState().TetrisModel.ticksPerMove;
            }
            else {
                if (this._state) {
                    return this._state.ticksPerMove;
                }
            }
            throw "Invalid State in TetrisModel_ticksPerMove";
        },
        set: function (value) {
            if (this._state && typeof value !== "undefined") {
                this._state.ticksPerMove = value;
            }
            else {
                // dispatch change for item ticksPerMove
                if (this._dispatch) {
                    this._dispatch({
                        type: exports.TetrisModelEnums.TetrisModel_ticksPerMove,
                        payload: value
                    });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTetrisModel.prototype, "tickCnt", {
        get: function () {
            if (this._getState) {
                return this._getState().TetrisModel.tickCnt;
            }
            else {
                if (this._state) {
                    return this._state.tickCnt;
                }
            }
            throw "Invalid State in TetrisModel_tickCnt";
        },
        set: function (value) {
            if (this._state && typeof value !== "undefined") {
                this._state.tickCnt = value;
            }
            else {
                // dispatch change for item tickCnt
                if (this._dispatch) {
                    this._dispatch({
                        type: exports.TetrisModelEnums.TetrisModel_tickCnt,
                        payload: value
                    });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTetrisModel.prototype, "dx", {
        get: function () {
            if (this._getState) {
                return this._getState().TetrisModel.dx;
            }
            else {
                if (this._state) {
                    return this._state.dx;
                }
            }
            throw "Invalid State in TetrisModel_dx";
        },
        set: function (value) {
            if (this._state && typeof value !== "undefined") {
                this._state.dx = value;
            }
            else {
                // dispatch change for item dx
                if (this._dispatch) {
                    this._dispatch({
                        type: exports.TetrisModelEnums.TetrisModel_dx,
                        payload: value
                    });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTetrisModel.prototype, "dy", {
        get: function () {
            if (this._getState) {
                return this._getState().TetrisModel.dy;
            }
            else {
                if (this._state) {
                    return this._state.dy;
                }
            }
            throw "Invalid State in TetrisModel_dy";
        },
        set: function (value) {
            if (this._state && typeof value !== "undefined") {
                this._state.dy = value;
            }
            else {
                // dispatch change for item dy
                if (this._dispatch) {
                    this._dispatch({
                        type: exports.TetrisModelEnums.TetrisModel_dy,
                        payload: value
                    });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    RTetrisModel.prototype.doesCollide = function (pieceX, pieceY, pieceCells) {
        var _this = this;
        var collides = false;
        var compareAgainst = pieceCells || this.activePiece.cells;
        compareAgainst.forEach(function (row, y) {
            row.forEach(function (cell, x) {
                if (cell.color === Colors.EMPTY)
                    return;
                if (pieceY + y >= _this.rows) {
                    collides = true;
                    return;
                }
                if (pieceX + x < 0 || pieceX + x >= _this.cols) {
                    collides = true;
                    return;
                }
                if (cell.color !== Colors.EMPTY) {
                    if (pieceY + y < 0)
                        return;
                    if (_this.cells[pieceY + y][pieceX + x].color !== Colors.EMPTY) {
                        collides = true;
                    }
                }
            });
        });
        return collides;
    };
    RTetrisModel.prototype.tick = function () {
        if (this._state) {
            this.tickCnt++;
            if (this.tickCnt >= this.ticksPerMove) {
                this.tickCnt = 0;
                this.step();
            }
        }
        else {
            if (this._dispatch) {
                this._dispatch({ type: exports.TetrisModelEnums.TetrisModel_tick });
            }
        }
    };
    RTetrisModel.tick = function () {
        return function (dispatcher, getState) {
            new RTetrisModel(undefined, dispatcher, getState).tick();
        };
    };
    RTetrisModel.prototype.left = function () {
        if (this._state) {
            if (!this.doesCollide(this.activePiece.x - 1, this.activePiece.y)) {
                this.activePiece.x--;
            }
        }
        else {
            if (this._dispatch) {
                this._dispatch({ type: exports.TetrisModelEnums.TetrisModel_left });
            }
        }
    };
    RTetrisModel.left = function () {
        return function (dispatcher, getState) {
            new RTetrisModel(undefined, dispatcher, getState).left();
        };
    };
    RTetrisModel.prototype.right = function () {
        if (this._state) {
            if (!this.doesCollide(this.activePiece.x + 1, this.activePiece.y)) {
                this.activePiece.x++;
            }
        }
        else {
            if (this._dispatch) {
                this._dispatch({ type: exports.TetrisModelEnums.TetrisModel_right });
            }
        }
    };
    RTetrisModel.right = function () {
        return function (dispatcher, getState) {
            new RTetrisModel(undefined, dispatcher, getState).right();
        };
    };
    RTetrisModel.prototype.rotate = function () {
        if (this._state) {
            var newOrientation = this.rotateCells(this.activePiece.cells);
            if (!this.doesCollide(this.activePiece.x, this.activePiece.y, newOrientation)) {
                this.activePiece.cells = newOrientation;
            }
        }
        else {
            if (this._dispatch) {
                this._dispatch({ type: exports.TetrisModelEnums.TetrisModel_rotate });
            }
        }
    };
    RTetrisModel.rotate = function () {
        return function (dispatcher, getState) {
            new RTetrisModel(undefined, dispatcher, getState).rotate();
        };
    };
    // creates a new piece with rotated values
    RTetrisModel.prototype.rotateCells = function (cells) {
        var res = new Array(cells.length);
        for (var j = 0; j < cells.length; j++) {
            res[j] = new Array(cells[j].length);
        }
        for (var j = 0; j < cells.length; j++) {
            var row = cells[j];
            for (var i = 0; i < row.length; i++) {
                res[i][j] = { color: Colors.EMPTY };
            }
        }
        for (var j = 0; j < cells.length; j++) {
            var row = cells[j];
            for (var i = 0; i < row.length; i++) {
                res[i][cells.length - j - 1] = row[i];
            }
        }
        return res;
    };
    RTetrisModel.prototype.step = function () {
        if (this._state) {
            if (this.gameOn) {
                if (!this.doesCollide(this.activePiece.x, this.activePiece.y + 1)) {
                    this.activePiece.y++;
                }
                else {
                    if (this.activePiece.y < 0) {
                        this.gameEnded = true;
                        this.gameOn = false;
                    }
                    else {
                        this.masonPiece();
                        this.dropRows();
                        this.activePiece = exports.createNewPiece(this.pickNextColor());
                        this.activePiece.x = Math.floor(Math.random() * 5);
                    }
                }
            }
        }
        else {
            if (this._dispatch) {
                this._dispatch({ type: exports.TetrisModelEnums.TetrisModel_step });
            }
        }
    };
    RTetrisModel.step = function () {
        return function (dispatcher, getState) {
            new RTetrisModel(undefined, dispatcher, getState).step();
        };
    };
    RTetrisModel.prototype.pickNextColor = function () {
        this.lastUsedColor++;
        if (this.lastUsedColor >= this.useColors.length) {
            this.lastUsedColor = 0;
        }
        return this.useColors[this.lastUsedColor];
    };
    RTetrisModel.prototype.masonPiece = function () {
        var _this = this;
        if (this._state) {
            var piece_1 = this.activePiece;
            piece_1.cells.forEach(function (row, y) {
                if (piece_1.y + y < 0)
                    return;
                row.forEach(function (cell, x) {
                    if (cell.color !== Colors.EMPTY) {
                        _this.cells[piece_1.y + y][piece_1.x + x].color = cell.color;
                    }
                });
            });
        }
        else {
            if (this._dispatch) {
                this._dispatch({ type: exports.TetrisModelEnums.TetrisModel_masonPiece });
            }
        }
    };
    RTetrisModel.masonPiece = function () {
        return function (dispatcher, getState) {
            new RTetrisModel(undefined, dispatcher, getState).masonPiece();
        };
    };
    RTetrisModel.prototype.dropRows = function () {
        if (this._state) {
            var nextRows = [];
            var emptyCnt = 0;
            for (var i = 0; i < this.cells.length; i++) {
                var row = this.cells[i];
                if (row.filter(function (cell) { return cell.color === Colors.EMPTY; }).length > 0) {
                    nextRows.push(row);
                }
                else {
                    emptyCnt++;
                }
            }
            if (emptyCnt > 0) {
                this.points += emptyCnt * emptyCnt * 10;
                while (emptyCnt-- > 0) {
                    var newEmpty = new Array(this.cols);
                    for (var col = 0; col < this.cols; col++) {
                        newEmpty[col] = { color: Colors.EMPTY };
                    }
                    nextRows.unshift(newEmpty);
                }
                this.cells = nextRows;
                this.ticksPerMove--;
            }
        }
        else {
            if (this._dispatch) {
                this._dispatch({ type: exports.TetrisModelEnums.TetrisModel_dropRows });
            }
        }
    };
    RTetrisModel.dropRows = function () {
        return function (dispatcher, getState) {
            new RTetrisModel(undefined, dispatcher, getState).dropRows();
        };
    };
    RTetrisModel.prototype.clearCells = function () {
        if (this._state) {
            this.cells = new Array(this.rows);
            for (var row = 0; row < this.rows; row++) {
                this.cells[row] = new Array(this.cols);
                for (var col = 0; col < this.cols; col++) {
                    this.cells[row][col] = { color: Colors.EMPTY };
                }
            }
        }
        else {
            if (this._dispatch) {
                this._dispatch({ type: exports.TetrisModelEnums.TetrisModel_clearCells });
            }
        }
    };
    RTetrisModel.clearCells = function () {
        return function (dispatcher, getState) {
            new RTetrisModel(undefined, dispatcher, getState).clearCells();
        };
    };
    RTetrisModel.prototype.resetGame = function () {
        if (this._state) {
            this.clearCells();
            this.activePiece = exports.createNewPiece(this.pickNextColor());
            this.ticksPerMove = 10;
            this.tickCnt = 0;
        }
        else {
            if (this._dispatch) {
                this._dispatch({ type: exports.TetrisModelEnums.TetrisModel_resetGame });
            }
        }
    };
    RTetrisModel.resetGame = function () {
        return function (dispatcher, getState) {
            new RTetrisModel(undefined, dispatcher, getState).resetGame();
        };
    };
    RTetrisModel.prototype.start = function () {
        if (this._state) {
            this.resetGame();
            this.gameOn = true;
            this.gameEnded = false;
            this.points = 0;
        }
        else {
            if (this._dispatch) {
                this._dispatch({ type: exports.TetrisModelEnums.TetrisModel_start });
            }
        }
    };
    RTetrisModel.start = function () {
        return function (dispatcher, getState) {
            new RTetrisModel(undefined, dispatcher, getState).start();
        };
    };
    return RTetrisModel;
}());
exports.RTetrisModel = RTetrisModel;
exports.TetrisModelEnums = {
    TetrisModel_useColors: "TetrisModel_useColors",
    TetrisModel_lastUsedColor: "TetrisModel_lastUsedColor",
    TetrisModel_points: "TetrisModel_points",
    TetrisModel_rows: "TetrisModel_rows",
    TetrisModel_cols: "TetrisModel_cols",
    TetrisModel_cells: "TetrisModel_cells",
    TetrisModel_activePiece: "TetrisModel_activePiece",
    TetrisModel_gameOn: "TetrisModel_gameOn",
    TetrisModel_gameEnded: "TetrisModel_gameEnded",
    TetrisModel_ticksPerMove: "TetrisModel_ticksPerMove",
    TetrisModel_tickCnt: "TetrisModel_tickCnt",
    TetrisModel_dx: "TetrisModel_dx",
    TetrisModel_dy: "TetrisModel_dy",
    TetrisModel_doesCollide: "TetrisModel_doesCollide",
    TetrisModel_tick: "TetrisModel_tick",
    TetrisModel_left: "TetrisModel_left",
    TetrisModel_right: "TetrisModel_right",
    TetrisModel_rotate: "TetrisModel_rotate",
    TetrisModel_rotateCells: "TetrisModel_rotateCells",
    TetrisModel_step: "TetrisModel_step",
    TetrisModel_pickNextColor: "TetrisModel_pickNextColor",
    TetrisModel_masonPiece: "TetrisModel_masonPiece",
    TetrisModel_dropRows: "TetrisModel_dropRows",
    TetrisModel_clearCells: "TetrisModel_clearCells",
    TetrisModel_resetGame: "TetrisModel_resetGame",
    TetrisModel_start: "TetrisModel_start"
};
exports.TetrisModelReducer = function (state, action) {
    if (state === void 0) { state = initTetrisModel(); }
    return immer.produce(state, function (draft) {
        switch (action.type) {
            case exports.TetrisModelEnums.TetrisModel_useColors:
                new RTetrisModel(draft).useColors = action.payload;
                break;
            case exports.TetrisModelEnums.TetrisModel_lastUsedColor:
                new RTetrisModel(draft).lastUsedColor = action.payload;
                break;
            case exports.TetrisModelEnums.TetrisModel_points:
                new RTetrisModel(draft).points = action.payload;
                break;
            case exports.TetrisModelEnums.TetrisModel_rows:
                new RTetrisModel(draft).rows = action.payload;
                break;
            case exports.TetrisModelEnums.TetrisModel_cols:
                new RTetrisModel(draft).cols = action.payload;
                break;
            case exports.TetrisModelEnums.TetrisModel_cells:
                new RTetrisModel(draft).cells = action.payload;
                break;
            case exports.TetrisModelEnums.TetrisModel_activePiece:
                new RTetrisModel(draft).activePiece = action.payload;
                break;
            case exports.TetrisModelEnums.TetrisModel_gameOn:
                new RTetrisModel(draft).gameOn = action.payload;
                break;
            case exports.TetrisModelEnums.TetrisModel_gameEnded:
                new RTetrisModel(draft).gameEnded = action.payload;
                break;
            case exports.TetrisModelEnums.TetrisModel_ticksPerMove:
                new RTetrisModel(draft).ticksPerMove = action.payload;
                break;
            case exports.TetrisModelEnums.TetrisModel_tickCnt:
                new RTetrisModel(draft).tickCnt = action.payload;
                break;
            case exports.TetrisModelEnums.TetrisModel_dx:
                new RTetrisModel(draft).dx = action.payload;
                break;
            case exports.TetrisModelEnums.TetrisModel_dy:
                new RTetrisModel(draft).dy = action.payload;
                break;
            case exports.TetrisModelEnums.TetrisModel_tick:
                new RTetrisModel(draft).tick();
                break;
            case exports.TetrisModelEnums.TetrisModel_left:
                new RTetrisModel(draft).left();
                break;
            case exports.TetrisModelEnums.TetrisModel_right:
                new RTetrisModel(draft).right();
                break;
            case exports.TetrisModelEnums.TetrisModel_rotate:
                new RTetrisModel(draft).rotate();
                break;
            case exports.TetrisModelEnums.TetrisModel_step:
                new RTetrisModel(draft).step();
                break;
            case exports.TetrisModelEnums.TetrisModel_masonPiece:
                new RTetrisModel(draft).masonPiece();
                break;
            case exports.TetrisModelEnums.TetrisModel_dropRows:
                new RTetrisModel(draft).dropRows();
                break;
            case exports.TetrisModelEnums.TetrisModel_clearCells:
                new RTetrisModel(draft).clearCells();
                break;
            case exports.TetrisModelEnums.TetrisModel_resetGame:
                new RTetrisModel(draft).resetGame();
                break;
            case exports.TetrisModelEnums.TetrisModel_start:
                new RTetrisModel(draft).start();
                break;
        }
    });
};
/********************************
 * React Context API component   *
 ********************************/
exports.TetrisModelContext = React.createContext(initWithMethodsTetrisModel());
exports.TetrisModelConsumer = exports.TetrisModelContext.Consumer;
var instanceCnt = 1;
var TetrisModelProvider = /** @class */ (function (_super) {
    __extends(TetrisModelProvider, _super);
    function TetrisModelProvider(props) {
        var _this = _super.call(this, props) || this;
        _this.state = initTetrisModel();
        _this.__devTools = null;
        _this.lastSetState = _this.state;
        _this.tick = _this.tick.bind(_this);
        _this.left = _this.left.bind(_this);
        _this.right = _this.right.bind(_this);
        _this.rotate = _this.rotate.bind(_this);
        _this.step = _this.step.bind(_this);
        _this.masonPiece = _this.masonPiece.bind(_this);
        _this.dropRows = _this.dropRows.bind(_this);
        _this.clearCells = _this.clearCells.bind(_this);
        _this.resetGame = _this.resetGame.bind(_this);
        _this.start = _this.start.bind(_this);
        var devs = window["devToolsExtension"]
            ? window["devToolsExtension"]
            : null;
        if (devs) {
            _this.__devTools = devs.connect({ name: "TetrisModel" + instanceCnt++ });
            _this.__devTools.init(_this.state);
            _this.__devTools.subscribe(function (msg) {
                if (msg.type === "DISPATCH" && msg.state) {
                    _this.setState(JSON.parse(msg.state));
                }
            });
        }
        return _this;
    }
    TetrisModelProvider.prototype.componentWillUnmount = function () {
        if (this.__devTools) {
            this.__devTools.unsubscribe();
        }
    };
    TetrisModelProvider.prototype.setStateSync = function (state) {
        this.lastSetState = state;
        this.setState(state);
    };
    TetrisModelProvider.prototype.tick = function () {
        var nextState = immer.produce(this.state, function (draft) {
            return new RTetrisModel(draft).tick();
        });
        if (this.__devTools) {
            this.__devTools.send("tick", nextState);
        }
        this.setStateSync(nextState);
    };
    TetrisModelProvider.prototype.left = function () {
        var nextState = immer.produce(this.state, function (draft) {
            return new RTetrisModel(draft).left();
        });
        if (this.__devTools) {
            this.__devTools.send("left", nextState);
        }
        this.setStateSync(nextState);
    };
    TetrisModelProvider.prototype.right = function () {
        var nextState = immer.produce(this.state, function (draft) {
            return new RTetrisModel(draft).right();
        });
        if (this.__devTools) {
            this.__devTools.send("right", nextState);
        }
        this.setStateSync(nextState);
    };
    TetrisModelProvider.prototype.rotate = function () {
        var nextState = immer.produce(this.state, function (draft) {
            return new RTetrisModel(draft).rotate();
        });
        if (this.__devTools) {
            this.__devTools.send("rotate", nextState);
        }
        this.setStateSync(nextState);
    };
    TetrisModelProvider.prototype.step = function () {
        var nextState = immer.produce(this.state, function (draft) {
            return new RTetrisModel(draft).step();
        });
        if (this.__devTools) {
            this.__devTools.send("step", nextState);
        }
        this.setStateSync(nextState);
    };
    TetrisModelProvider.prototype.masonPiece = function () {
        var nextState = immer.produce(this.state, function (draft) {
            return new RTetrisModel(draft).masonPiece();
        });
        if (this.__devTools) {
            this.__devTools.send("masonPiece", nextState);
        }
        this.setStateSync(nextState);
    };
    TetrisModelProvider.prototype.dropRows = function () {
        var nextState = immer.produce(this.state, function (draft) {
            return new RTetrisModel(draft).dropRows();
        });
        if (this.__devTools) {
            this.__devTools.send("dropRows", nextState);
        }
        this.setStateSync(nextState);
    };
    TetrisModelProvider.prototype.clearCells = function () {
        var nextState = immer.produce(this.state, function (draft) {
            return new RTetrisModel(draft).clearCells();
        });
        if (this.__devTools) {
            this.__devTools.send("clearCells", nextState);
        }
        this.setStateSync(nextState);
    };
    TetrisModelProvider.prototype.resetGame = function () {
        var nextState = immer.produce(this.state, function (draft) {
            return new RTetrisModel(draft).resetGame();
        });
        if (this.__devTools) {
            this.__devTools.send("resetGame", nextState);
        }
        this.setStateSync(nextState);
    };
    TetrisModelProvider.prototype.start = function () {
        var nextState = immer.produce(this.state, function (draft) {
            return new RTetrisModel(draft).start();
        });
        if (this.__devTools) {
            this.__devTools.send("start", nextState);
        }
        this.setStateSync(nextState);
    };
    TetrisModelProvider.prototype.render = function () {
        return (React.createElement(exports.TetrisModelContext.Provider, { value: __assign({}, this.state, { tick: this.tick, left: this.left, right: this.right, rotate: this.rotate, step: this.step, masonPiece: this.masonPiece, dropRows: this.dropRows, clearCells: this.clearCells, resetGame: this.resetGame, start: this.start }) },
            " ",
            this.props.children));
    };
    return TetrisModelProvider;
}(React.Component));
exports.TetrisModelProvider = TetrisModelProvider;
//# sourceMappingURL=TetrisModel.js.map