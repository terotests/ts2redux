/********************************************************************************
 *                                                                               *
 *   Redux Reducers and React Context API Provider/Consumer for state TodoList   *
 *   Generated by ts2redux from Source file ../TodoList.ts                       *
 *                                                                               *
 ********************************************************************************/
import { TodoListItem } from "../interfaces";
import { loadables, loadable, LoadableType } from "../loadables";
export declare type TaskState = "UNDEFINED" | "RUNNING" | "LOADED" | "ERROR";
export declare enum SortOrder {
    ASC = "asc",
    DESC = "desc"
}
/**
 * @redux true
 */
export declare class TodoList extends loadables {
    items: TodoListItem[];
    state: TaskState;
    stateError: any;
    sortOrder: SortOrder;
    listStart: number;
    listPageLength: number;
    listTitle: string;
    readonly listToDisplay: TodoListItem[];
    protected findMaxId(): number;
    nextPage(): void;
    prevPage(): void;
    toggleSortOrder(): void;
    clearTodoList(): void;
    reverse(): void;
    sortById(): void;
    sortByTitle(): void;
    sortByCompletion(): void;
    setTitle(value: string): void;
    addLotOfItems(cnt: number): void;
    /**
     * Fetch items from json placeholder service
     */
    getItems(): Promise<void>;
}
import { IState } from "./index";
import * as React from "react";
export interface IContainerPropsMethods {
    nextPage: () => any;
    prevPage: () => any;
    toggleSortOrder: () => any;
    clearTodoList: () => any;
    reverse: () => any;
    sortById: () => any;
    sortByTitle: () => any;
    sortByCompletion: () => any;
    setTitle: (value: string) => any;
    addLotOfItems: (cnt: number) => any;
    getItems: () => any;
    initState: (name: string) => any;
    setLoadState: (opts: {
        name: string;
        state: TaskState;
    }) => any;
    setData: (opts: {
        name: string;
        data: any;
    }) => any;
    setError: (opts: {
        name: string;
        err: any;
    }) => any;
}
export interface ITodoList {
    items: TodoListItem[];
    state: TaskState;
    stateError: any;
    sortOrder: SortOrder;
    listStart: number;
    listPageLength: number;
    listTitle: string;
    loadables: LoadableType;
}
export declare const itemsSelectorFn: (state: ITodoList) => TodoListItem[];
export declare const stateSelectorFn: (state: ITodoList) => import("../loadables").TaskState;
export declare const stateErrorSelectorFn: (state: ITodoList) => any;
export declare const sortOrderSelectorFn: (state: ITodoList) => SortOrder;
export declare const listStartSelectorFn: (state: ITodoList) => number;
export declare const listPageLengthSelectorFn: (state: ITodoList) => number;
export declare const listTitleSelectorFn: (state: ITodoList) => string;
export declare const loadablesSelectorFn: (state: ITodoList) => LoadableType;
export declare const listToDisplaySelectorFnCreator: () => import("reselect").OutputSelector<ITodoList, TodoListItem[], (res1: TodoListItem[], res2: SortOrder, res3: number, res4: number) => TodoListItem[]>;
export declare const listToDisplaySelector: import("reselect").OutputSelector<ITodoList, TodoListItem[], (res1: TodoListItem[], res2: SortOrder, res3: number, res4: number) => TodoListItem[]>;
export interface IContainerPropsState extends ITodoList {
    listToDisplay: TodoListItem[];
}
export interface IProps extends IContainerPropsState, IContainerPropsMethods {
}
export declare const mapStateToProps: (state: IState) => IContainerPropsState;
export declare const mapDispatchToProps: (dispatch: any) => IContainerPropsMethods;
export declare const StateConnector: any;
/**
 * @generated true
 */
export declare class RTodoList extends TodoList {
    private _state?;
    private _dispatch?;
    private _getState?;
    constructor(state?: ITodoList, dispatch?: (action: any) => void, getState?: () => any);
    items: TodoListItem[];
    state: TaskState;
    stateError: any;
    sortOrder: SortOrder;
    listStart: number;
    listPageLength: number;
    listTitle: string;
    loadables: LoadableType;
    protected findMaxId(): number;
    nextPage(): void;
    static nextPage(): (dispatcher: any, getState: any) => void;
    prevPage(): void;
    static prevPage(): (dispatcher: any, getState: any) => void;
    toggleSortOrder(): void;
    static toggleSortOrder(): (dispatcher: any, getState: any) => void;
    clearTodoList(): void;
    static clearTodoList(): (dispatcher: any, getState: any) => void;
    reverse(): void;
    static reverse(): (dispatcher: any, getState: any) => void;
    sortById(): void;
    static sortById(): (dispatcher: any, getState: any) => void;
    sortByTitle(): void;
    static sortByTitle(): (dispatcher: any, getState: any) => void;
    sortByCompletion(): void;
    static sortByCompletion(): (dispatcher: any, getState: any) => void;
    setTitle(value: string): void;
    static setTitle(value: string): (dispatcher: any, getState: any) => void;
    addLotOfItems(cnt: number): void;
    static addLotOfItems(cnt: number): (dispatcher: any, getState: any) => void;
    /**
     * Fetch items from json placeholder service
     */
    getItems(): Promise<void>;
    static getItems(): (dispatcher: any, getState: any) => void;
    initState(name: string): void;
    static initState(name: string): (dispatcher: any, getState: any) => void;
    setLoadState(opts: {
        name: string;
        state: TaskState;
    }): void;
    static setLoadState(opts: {
        name: string;
        state: TaskState;
    }): (dispatcher: any, getState: any) => void;
    setData(opts: {
        name: string;
        data: any;
    }): void;
    static setData(opts: {
        name: string;
        data: any;
    }): (dispatcher: any, getState: any) => void;
    setError(opts: {
        name: string;
        err: any;
    }): void;
    static setError(opts: {
        name: string;
        err: any;
    }): (dispatcher: any, getState: any) => void;
    protected loadItems<T extends loadable>(state: T, key: string, loader: () => Promise<any>, ready?: (data: any) => void): Promise<void>;
}
export declare const TodoListEnums: {
    TodoList_items: string;
    TodoList_state: string;
    TodoList_stateError: string;
    TodoList_sortOrder: string;
    TodoList_listStart: string;
    TodoList_listPageLength: string;
    TodoList_listTitle: string;
    TodoList_loadables: string;
    TodoList_findMaxId: string;
    TodoList_nextPage: string;
    TodoList_prevPage: string;
    TodoList_toggleSortOrder: string;
    TodoList_clearTodoList: string;
    TodoList_reverse: string;
    TodoList_sortById: string;
    TodoList_sortByTitle: string;
    TodoList_sortByCompletion: string;
    TodoList_setTitle: string;
    TodoList_addLotOfItems: string;
    TodoList_initState: string;
    TodoList_setLoadState: string;
    TodoList_setData: string;
    TodoList_setError: string;
};
export declare const TodoListReducer: (state: ITodoList, action: any) => ITodoList;
/********************************
 * React Context API component   *
 ********************************/
export declare const TodoListContext: React.Context<IProps>;
export declare const TodoListConsumer: React.ComponentType<React.ConsumerProps<IProps>>;
export declare class TodoListProvider extends React.Component {
    state: ITodoList;
    lastSetState: ITodoList;
    private __devTools;
    private __selectorlistToDisplay;
    constructor(props: any);
    componentWillUnmount(): void;
    setStateSync(state: ITodoList): void;
    nextPage(): void;
    prevPage(): void;
    toggleSortOrder(): void;
    clearTodoList(): void;
    reverse(): void;
    sortById(): void;
    sortByTitle(): void;
    sortByCompletion(): void;
    setTitle(value: string): void;
    addLotOfItems(cnt: number): void;
    /**
     * Fetch items from json placeholder service
     */
    getItems(): Promise<void>;
    initState(name: string): void;
    setLoadState(opts: {
        name: string;
        state: TaskState;
    }): void;
    setData(opts: {
        name: string;
        data: any;
    }): void;
    setError(opts: {
        name: string;
        err: any;
    }): void;
    render(): JSX.Element;
}
