/********************************************************************************
*                                                                               *
*   Redux Reducers and React Context API Provider/Consumer for state TodoList   *
*   Generated by ts2redux from Source file ../TodoList.ts                       *
*                                                                               *
********************************************************************************/

import axios from 'axios'

export interface TodoListItem {
  userId: number
  id: number
  title: string
  completed: boolean
}

export type TaskState = 'UNDEFINED' | 'RUNNING' |  'LOADED' | 'ERROR'
/**
 * @redux true
 */
export class TodoList {
  items: TodoListItem[] = []
  state: TaskState = 'UNDEFINED'
  stateError: any

  clearTodoList() {
    this.items = []
  }
  reverse() {
    this.items.reverse()
  }  
  sortById() {
    this.items.sort( (a, b) => a.id - b.id )
  }
  sortByTitle() {
    this.items.sort( (a, b) => a.title.localeCompare( b.title ) )
  }
  sortByCompletion() {
    const toNumber = (value:boolean) : number => value ? 1 : 0;
    this.items.sort( (a, b) => toNumber(a.completed) - toNumber(b.completed) )
  }
  /**
   * Fetch items from json placeholder service
   */
  async getItems() {
    if(this.state === 'RUNNING') return
    try {
      this.state = 'RUNNING'
      this.items = (await axios.get('https://jsonplaceholder.typicode.com/todos')).data
      this.state = 'LOADED'
    } catch(e) {
      this.state = 'ERROR'
      this.stateError = e
    }
  }
}

import * as immer from 'immer'
import { connect } from 'react-redux'
import { IState } from './index'
import * as React from 'react'

export interface IContainerPropsMethods {
  clearTodoList? : () => any
  reverse? : () => any
  sortById? : () => any
  sortByTitle? : () => any
  sortByCompletion? : () => any
  getItems? : () => any
}
export interface ITodoList {
  items: TodoListItem[]
  state: TaskState
  stateError: any
}

type IContainerPropsState = ITodoList
export interface IProps extends IContainerPropsState, IContainerPropsMethods {}
export const mapStateToProps = (state : IState) : IContainerPropsState => {
  return {
    items: state.TodoList.items,
    state: state.TodoList.state,
    stateError: state.TodoList.stateError,
  }
}
export const mapDispatchToProps = (dispatch:any) : IContainerPropsMethods => {
  return {
    clearTodoList : () => {
      return dispatch(RTodoList.clearTodoList())
    },
    reverse : () => {
      return dispatch(RTodoList.reverse())
    },
    sortById : () => {
      return dispatch(RTodoList.sortById())
    },
    sortByTitle : () => {
      return dispatch(RTodoList.sortByTitle())
    },
    sortByCompletion : () => {
      return dispatch(RTodoList.sortByCompletion())
    },
    getItems : () => {
      return dispatch(RTodoList.getItems())
    },
  }
}
export const StateConnector = connect( mapStateToProps, mapDispatchToProps);

const initTodoList = () => {
  const o = new TodoList();
  return {
    items: o.items,
    state: o.state,
    stateError: o.stateError,
  }
}

/**
 * @generated true
 */
export class RTodoList {
  private _state?: ITodoList
  private _dispatch?: (action:any)=>void
  private _getState?: ()=>any
  constructor(state?: ITodoList, dispatch?:(action:any)=>void, getState?:()=>any) {
    this._state = state
    this._dispatch = dispatch
    this._getState = getState
  }
  get items() : TodoListItem[] | undefined {
    if(this._getState) {
      return this._getState().TodoList.items
    } else {
      if(this._state) { return this._state.items }
    }
    return undefined}
  set items(value:TodoListItem[] | undefined) {
    if(this._state && (typeof(value) !== 'undefined')) {
      this._state.items = value
    } else {
      // dispatch change for item items
      if(this._dispatch) { this._dispatch({type:TodoListEnums.TodoList_items, payload:value}) }
    }
  }
  get state() : TaskState | undefined {
    if(this._getState) {
      return this._getState().TodoList.state
    } else {
      if(this._state) { return this._state.state }
    }
    return undefined}
  set state(value:TaskState | undefined) {
    if(this._state && (typeof(value) !== 'undefined')) {
      this._state.state = value
    } else {
      // dispatch change for item state
      if(this._dispatch) { this._dispatch({type:TodoListEnums.TodoList_state, payload:value}) }
    }
  }
  get stateError() : any | undefined {
    if(this._getState) {
      return this._getState().TodoList.stateError
    } else {
      if(this._state) { return this._state.stateError }
    }
    return undefined}
  set stateError(value:any | undefined) {
    if(this._state && (typeof(value) !== 'undefined')) {
      this._state.stateError = value
    } else {
      // dispatch change for item stateError
      if(this._dispatch) { this._dispatch({type:TodoListEnums.TodoList_stateError, payload:value}) }
    }
  }
  
  // is a reducer
  clearTodoList(){
    if(this._state) {
      this.items = [];
    } else {
      if(this._dispatch) { this._dispatch({type:TodoListEnums.TodoList_clearTodoList}) }
    }
  }
  
  public static clearTodoList(){
    return (dispatcher:any, getState:any) => {
      (new RTodoList(undefined, dispatcher, getState)).clearTodoList()
    }
  }
  // is a reducer
  reverse(){
    if(this._state) {
      this.items.reverse();
    } else {
      if(this._dispatch) { this._dispatch({type:TodoListEnums.TodoList_reverse}) }
    }
  }
  
  public static reverse(){
    return (dispatcher:any, getState:any) => {
      (new RTodoList(undefined, dispatcher, getState)).reverse()
    }
  }
  // is a reducer
  sortById(){
    if(this._state) {
      this.items.sort((a, b) => a.id - b.id);
    } else {
      if(this._dispatch) { this._dispatch({type:TodoListEnums.TodoList_sortById}) }
    }
  }
  
  public static sortById(){
    return (dispatcher:any, getState:any) => {
      (new RTodoList(undefined, dispatcher, getState)).sortById()
    }
  }
  // is a reducer
  sortByTitle(){
    if(this._state) {
      this.items.sort((a, b) => a.title.localeCompare(b.title));
    } else {
      if(this._dispatch) { this._dispatch({type:TodoListEnums.TodoList_sortByTitle}) }
    }
  }
  
  public static sortByTitle(){
    return (dispatcher:any, getState:any) => {
      (new RTodoList(undefined, dispatcher, getState)).sortByTitle()
    }
  }
  // is a reducer
  sortByCompletion(){
    if(this._state) {
      const toNumber = (value: boolean): number => value ? 1 : 0;
      this.items.sort((a, b) => toNumber(a.completed) - toNumber(b.completed));
    } else {
      if(this._dispatch) { this._dispatch({type:TodoListEnums.TodoList_sortByCompletion}) }
    }
  }
  
  public static sortByCompletion(){
    return (dispatcher:any, getState:any) => {
      (new RTodoList(undefined, dispatcher, getState)).sortByCompletion()
    }
  }
  // is task
  /**
   * Fetch items from json placeholder service
   */
  async getItems() {
      if (this.state === 'RUNNING')
          return;
      try {
          this.state = 'RUNNING';
          this.items = (await axios.get('https://jsonplaceholder.typicode.com/todos')).data;
          this.state = 'LOADED';
      }
      catch (e) {
          this.state = 'ERROR';
          this.stateError = e;
      }
  }
  
  public static getItems(){
    return (dispatcher:any, getState:any) => {
      (new RTodoList(undefined, dispatcher, getState)).getItems()
    }
  }
}

export const TodoListEnums = {
  TodoList_items : 'TodoList_items',
  TodoList_state : 'TodoList_state',
  TodoList_stateError : 'TodoList_stateError',
  TodoList_clearTodoList : 'TodoList_clearTodoList',
  TodoList_reverse : 'TodoList_reverse',
  TodoList_sortById : 'TodoList_sortById',
  TodoList_sortByTitle : 'TodoList_sortByTitle',
  TodoList_sortByCompletion : 'TodoList_sortByCompletion',
}

export const TodoListReducer = (state:ITodoList = initTodoList(), action:any ) => {
  return immer.produce(state, draft => {
    switch (action.type) {
      case TodoListEnums.TodoList_items: 
        (new RTodoList(draft)).items = action.payload
        break;
      case TodoListEnums.TodoList_state: 
        (new RTodoList(draft)).state = action.payload
        break;
      case TodoListEnums.TodoList_stateError: 
        (new RTodoList(draft)).stateError = action.payload
        break;
      case TodoListEnums.TodoList_clearTodoList: 
        (new RTodoList(draft)).clearTodoList()
        break;
      case TodoListEnums.TodoList_reverse: 
        (new RTodoList(draft)).reverse()
        break;
      case TodoListEnums.TodoList_sortById: 
        (new RTodoList(draft)).sortById()
        break;
      case TodoListEnums.TodoList_sortByTitle: 
        (new RTodoList(draft)).sortByTitle()
        break;
      case TodoListEnums.TodoList_sortByCompletion: 
        (new RTodoList(draft)).sortByCompletion()
        break;
    }
  })
}
/***************************
* React Context API test   *
***************************/
export const TodoListContext = React.createContext<IProps>(initTodoList())
export const TodoListConsumer = TodoListContext.Consumer
let instanceCnt = 1
export class TodoListProvider extends React.Component {
  public state: ITodoList = initTodoList() 
  private __devTools:any = null
  constructor( props:any ){
    super(props)
    this.clearTodoList = this.clearTodoList.bind(this)
    this.reverse = this.reverse.bind(this)
    this.sortById = this.sortById.bind(this)
    this.sortByTitle = this.sortByTitle.bind(this)
    this.sortByCompletion = this.sortByCompletion.bind(this)
    this.getItems = this.getItems.bind(this)
    const devs = window['devToolsExtension'] ? window['devToolsExtension'] : null
    if(devs) {
      this.__devTools = devs.connect({name:'TodoList'+instanceCnt++})
      this.__devTools.init(this.state)
      this.__devTools.subscribe( (msg:any) => {
        if (msg.type === 'DISPATCH' && msg.state) {
          this.setState(JSON.parse(msg.state))
        }
      })
    }
  }
  public componentWillUnmount() {
    if(this.__devTools) { this.__devTools.unsubscribe() }
  }
  clearTodoList(){
    const nextState = immer.produce( this.state, draft => ( new RTodoList(draft) ).clearTodoList() )
    if(this.__devTools) this.__devTools.send('clearTodoList', nextState)
    this.setState(nextState)
  }
  reverse(){
    const nextState = immer.produce( this.state, draft => ( new RTodoList(draft) ).reverse() )
    if(this.__devTools) this.__devTools.send('reverse', nextState)
    this.setState(nextState)
  }
  sortById(){
    const nextState = immer.produce( this.state, draft => ( new RTodoList(draft) ).sortById() )
    if(this.__devTools) this.__devTools.send('sortById', nextState)
    this.setState(nextState)
  }
  sortByTitle(){
    const nextState = immer.produce( this.state, draft => ( new RTodoList(draft) ).sortByTitle() )
    if(this.__devTools) this.__devTools.send('sortByTitle', nextState)
    this.setState(nextState)
  }
  sortByCompletion(){
    const nextState = immer.produce( this.state, draft => ( new RTodoList(draft) ).sortByCompletion() )
    if(this.__devTools) this.__devTools.send('sortByCompletion', nextState)
    this.setState(nextState)
  }
  /**
   * Fetch items from json placeholder service
   */
  async getItems(){
    (new RTodoList(undefined, (action:any) => {
      const nextState = TodoListReducer( this.state, action )
      if(this.__devTools) { this.__devTools.send(action.type, nextState) }
      this.setState(nextState)
    }, () => ({TodoList:this.state})) ).getItems()
  }
  public render() {
    return (<TodoListContext.Provider value={{...this.state, 
      clearTodoList: this.clearTodoList,
      reverse: this.reverse,
      sortById: this.sortById,
      sortByTitle: this.sortByTitle,
      sortByCompletion: this.sortByCompletion,
      getItems: this.getItems,
    }}> {this.props.children} 
    </TodoListContext.Provider>)
  }
}
